#!/bin/bash
set -o pipefail

plugin="buddybackup"

# cd /mnt/user/sonic/buddybackup_plugin && ./makepkg.sh && upgradepkg --install-new --reinstall buddybackup.txz

list_descendants() {
  local children=$(ps -o pid= --ppid "$1")
  for pid in $children; do
    list_descendants "$pid"
  done
  echo "$children"
}
cleanup() {
    # Kill child processes
    kill $(list_descendants $$) >/dev/null 2>&1
}
trap cleanup EXIT

unraid_notify() {
    # Call the Unraid notification script
    /usr/local/emhttp/webGui/scripts/notify -s "BuddyBackup" -d "$1" -i "$2"
}

# Default output is console, use optional parameter "nchan" to write to that nchan channel as well
write() {
    local nchan="$1"
    shift  # Shift arguments to access messages

    if [[ -n "$nchan" ]]; then
        local url="http://localhost/pub/buddybackup-${nchan}?buffer_length=10"
        local socket="/var/run/nginx.socket"

        for message in "$@"; do
            curl -o /dev/null --unix-socket "${socket}" -X POST -d "${message}" "${url}" >/dev/null 2>&1
        done
    fi
    
    for message in "$@"; do
        echo "${message}"
    done
}

# Runs cmd and continously sends output to nchan if specified, otherwise runs cmd and echos result afterwards
run_and_write_output() {
    local nchan="$1"  # Set to empty string to only write to console. Otherwise it will be sent to the nchan channel with this name
    local cmd="$2"

    if [[ -n "$nchan" ]]; then
        local url="http://localhost/pub/buddybackup-${nchan}?buffer_length=10"
        local socket="/var/run/nginx.socket"

        cmd+=" | tee >( stdbuf -oL tr '\r' '\n' | xargs -I % curl -o /dev/null --unix-socket \"${socket}\" -X POST --data-binary \"%\" \"${url}\" >/dev/null 2>&1)"
    fi

    result=$(eval "$cmd")
    local error_code=$?
    echo "${result}"
    return "${error_code}"
}

enable_backups_to_buddy() {
    logger "Enabling BuddyBackup" -t"${plugin}"

    # remove old entries to known_host
    stripped=$(sed -n '1,/# buddybackup start/p;/# buddybackup end/,$p' ~/.ssh/known_hosts | sed -n '/^# buddybackup /d;p')
    echo "${stripped}" > ~/.ssh/known_hosts

    # append target as known host. This gets rid of strange hostfile_replace_entries/update_known_hosts errors during remote ssh commands
    echo "# buddybackup start" >> ~/.ssh/known_hosts
    ssh-keyscan -H "${DestinationHost}" >> ~/.ssh/known_hosts
    echo "# buddybackup end" >> ~/.ssh/known_hosts

    # test SSH connection to buddy
    eval $(test_connection "${DestinationHost}")
    if [[ "${connection_status}" == "ok" ]]; then
        logger "buddy auth ok" -t"${plugin}"
    else
        logger "failed to connect to buddy: ${connection_result}" -t"${plugin}"
        return
    fi

    if [[ ! -z "${BackupCron}" ]] then
        enable_syncoid_cron
    else
        disable_syncoid_cron
    fi
}

disable_backups_to_buddy() {
    logger "Disabling BuddyBackup" -t"${plugin}"
    disable_syncoid_cron
}

enable_backups_from_buddy() {
    if [[ -z "${ReceiveDestinationDataset}" ]]; then
        err="Can not enable backups from buddy, no recieve destination dataset set."
        logger "${err}" -t"${plugin}"
        echo "${err}"
        return
    fi

    # add buddybackup to "AllowUsers list" in /etc/ssh/sshd_config if AllowUsers exists (and restart sshd)
    # note: This probably makes it incompatible with other plugins that modify this line, such as "SSH Config Tool" by DocGyver
    sed -i 's/^#\?AllowUsers .*/AllowUsers root/' /etc/ssh/sshd_config
    sed -i 's/^#\?AllowUsers \(.*\)/AllowUsers \1 '${username}'/' /etc/ssh/sshd_config
    /etc/rc.d/rc.sshd restart >/dev/null 2>&1

    # make buddybackup user (with a homedir)
    useradd -m -s /bin/bash "${username}" >/dev/null 2>&1
    # copy public key to homedir/.ssh/authorized_keys. prepend with: 'restrict,command="path/to/restrict_zfs" '
    mkdir "/home/${username}/.ssh" >/dev/null 2>&1
    chmod 700 "/home/${username}/.ssh"
    touch "/home/${username}/.ssh/authorized_keys" >/dev/null 2>&1
    chmod 644 "/home/${username}/.ssh/authorized_keys"
    chown -R ${username}:${username} "/home/${username}/"
    echo "restrict,command=\"${empath}/deps/restrict_zfs\" ${DestinationPubSSHKey}" > "/home/${username}/.ssh/authorized_keys"

    zfs allow -u "${username}" create,mount,receive,send "${ReceiveDestinationDataset}"

    update_sanoid_conf

    enable_sanoid_cron
}

disable_backups_from_buddy() {
    # remove buddybackup from "AllowUsers list" in /etc/ssh/sshd_config (and restart sshd)
    sed -i 's/ '${username}'//' /etc/ssh/sshd_config
    /etc/rc.d/rc.sshd restart >/dev/null 2>&1

    rm -r "/home/${username}" >/dev/null 2>&1

    # todo: if $ReceiveDestinationDataset has changed since enable_backups_from_buddy() we don't know which dataset to zfs unallow. Fix that
    if [[ "${ReceiveDestinationDataset}" ]]; then
        zfs unallow -u "${username}" create,mount,receive,send "${ReceiveDestinationDataset}" >/dev/null 2>&1
    fi

    userdel "${username}" >/dev/null 2>&1

    disable_sanoid_cron
}

enable_syncoid_cron() {
    logger "Enabling syncoid cron" -t"${plugin}"

    rm "${syncoid_cron_file}" >/dev/null 2>&1
    echo "# Generated cron settings for plugin buddybackup" > "${syncoid_cron_file}"
    echo "${BackupCron} flock -n /var/lock/buddybackup-syncoid -c \"${empath}/scripts/rc.buddybackup send_backup\" 2>&1 | ${log_script}" >> "${syncoid_cron_file}"
    echo -e "\n" >> "${syncoid_cron_file}"
    /usr/local/sbin/update_cron
}

disable_syncoid_cron() {
    logger "Disabling syncoid cron" -t"${plugin}"

    rm "${syncoid_cron_file}" >/dev/null 2>&1
    /usr/local/sbin/update_cron
}

update() {
    # generate new ssh keys to access buddy if the keys don't already exist
    if [ ! -f "${ssh_key_path}" ] || [ ! -f "${ssh_key_path}.pub" ]; then
        echo "Generating new key pair.."
        rm "${ssh_key_path}" >/dev/null 2>&1
        rm "${ssh_key_path}.pub" >/dev/null 2>&1
        ssh-keygen -q -t ed25519 -f "${ssh_key_path}" -N ''
    fi

    # Make sure deps are executable
    chmod +x "${sanoid_bin}"
    chmod +x "${syncoid_bin}"

    if [[ "${BackupToBuddy}" == "enable" ]] then
        enable_backups_to_buddy
    else
        disable_backups_to_buddy
    fi

    if [[ "${ReceiveBackups}" == "enable" ]] then
        enable_backups_from_buddy
    else
        disable_backups_from_buddy
    fi
}

dataset_exists() {
    local dataset="$1"
    [[ $(zfs get -Ho value type "${dataset}" 2>&1) != *"dataset does not exist" ]]
}
is_encrypted() {
    local dataset="$1"
    [[ $(zfs get -Ho value encryption "${dataset}" 2>&1) != "off" ]]
}

send_backup() {
    logger "Sending backup to buddy" -t"${plugin}"

    local nchan="send"
    error=""
    if ! is_encrypted "${SourceDataset}"; then
        error="Source dataset '${SourceDataset}' is not encrypted!"
    fi
    if ! dataset_exists "${SourceDataset}"; then
        error="Source dataset '${SourceDataset}' does not exist!"
    fi

    if [ -n "${error}" ]; then
        error="Aborting backup. ${error}"
        write "${nchan}" "${error}"
        if [[ ! "${1}" == "echo" ]]; then
            unraid_notify "${error}" "alert"
        fi
        return
    fi

    local my_syncoid_flags="${syncoid_flags}"
    if [[ "${BackupRecursive}" == "yes" ]] then
        my_syncoid_flags+=" --recursive"
    fi
    if result=$(run_and_write_output "${nchan}" "${syncoid_bin} ${my_syncoid_flags} --sshkey \"${ssh_key_path}\" \"${SourceDataset}\" \"${username}@${DestinationHost}:${SendDestinationDataset}\" 2>&1"); then
        printf -v result "\nSuccessfully synced backup to buddy!"
    else 
        local error_code=$?
        unraid_notify "Sending backup failed. Error code ${error_code}. Full output: ${result}" "alert"
        printf -v result "Sending backup failed. Error code ${error_code}."
    fi
    write "${nchan}" "${result}"

    if [[ "${nchan}" ]]; then
        write "${nchan}" "[[rc.buddybackup finished]]"
    fi
}

restore_snapshot() {
    mode=$1
    snapshot=$2
    source_dataset=$3
    destination_dataset=$4

    # If last param is "nchan" we send output to nchan channel "restore" instead of echo
    nchan=$5
    if [[ "${nchan}" == "nchan" ]]; then
        nchan="restore"
    else
        nchan=""
    fi

    logger "Restoring backup from buddy" -t"${plugin}"

    error_code=-1
    result=""
    case "$mode" in
        ('selected')
            result=$(run_and_write_output "${nchan}" "${syncoid_bin} ${syncoid_flags} --include-snaps=\"${snapshot}\" --sshkey \"${ssh_key_path}\" \"${username}@${DestinationHost}:${source_dataset}\" \"${destination_dataset}\" 2>&1");
            error_code=$?
        ;;
        ('selected_and_newer')
            # todo: this requires something like
            # syncoid --include-snaps="(?:wanted_snapshot|newer_snap1|newer_snap2|...|common_parent_snapshot)
            # but common_parent_snapshot has to be found which is the hard part
            write "${nchan}" "Restore mode '${mode}' is not implemented yet"
            return
        ;;
        ('all')
            result=$(run_and_write_output "${nchan}" "${syncoid_bin} ${syncoid_flags} --sshkey \"${ssh_key_path}\" \"${username}@${DestinationHost}:${source_dataset}\" \"${destination_dataset}\" 2>&1");
            error_code=$?
        ;;
        (*)
            write "${nchan}" "Invalid restore mode specified: (${mode})"
            return
    esac

    if [ $error_code -eq 0 ]; then
        if [[ -n "${nchan}" ]]; then
            printf -v result "\nSuccessfully restored from buddy!"
            unraid_notify "Restoring from buddy finished successfully!" "normal"
        else
            printf -v result "${result}\n\nSuccessfully restored from buddy!"
        fi
    else 
        full_error=""
        printf -v full_error "Restoring from buddy failed. Error code ${error_code}. Full output:\n\n${result}"
        if [[ -n "${nchan}" ]]; then
            unraid_notify "${full_error}" "alert"
            printf -v result "Restoring from buddy failed. Error code ${error_code}."
        else
            result="${full_error}"
        fi
    fi
    write "${nchan}" "${result}"

    if [[ "${nchan}" ]]; then
        write "${nchan}" "[[rc.buddybackup finished]]"
    fi
}

enable_sanoid_cron() {
    rm "${sanoid_cron_file}" >/dev/null 2>&1
    echo "# Generated cron settings for plugin buddybackup" > "${sanoid_cron_file}"
    echo "*/15 * * * * flock -n /var/lock/buddybackup-sanoid-cron -c \"TZ=UTC ${sanoid_bin} --configdir=\"${plugin_path}\" --cron\" 2>&1 | ${log_script}" >> "${sanoid_cron_file}"
    # Using the two lines below threw wierd lock errors, so trying the one above now with just --cron
    # echo "*/15 * * * * flock -n /var/lock/buddybackup-sanoid-cron-take -c \"TZ=UTC ${sanoid_bin} --configdir=\"${plugin_path}\" --take-snapshots\" 2>&1 | ${log_script}" >> "${sanoid_cron_file}"
    # echo "*/15 * * * * flock -n /var/lock/buddybackup-sanoid-cron-prune -c \"${sanoid_bin} --configdir=\"${plugin_path}\" --prune-snapshots\" 2>&1 | ${log_script}" >> "${sanoid_cron_file}"
    echo -e "\n" >> "${sanoid_cron_file}"
    /usr/local/sbin/update_cron
}

disable_sanoid_cron() {
    rm "${sanoid_cron_file}" >/dev/null 2>&1
    /usr/local/sbin/update_cron
}

test_connection() {
    host=$1
    if [[ -z "${host}" ]] then
        host="${DestinationHost}"
    fi
    # test SSH connection to buddy
    ssh_status=$(ssh -i "${ssh_key_path}" -o BatchMode=yes -o ConnectTimeout=5 "${username}@${host}" echo ok 2>&1)
    if [[ "${ssh_status}" == ok ]] || [[ "${ssh_status}" == *"hostfile_replace_entries"* ]]; then
        echo "connection_status=\"ok\"; connection_result=\"${ssh_status}\""
    elif [[ "${ssh_status}" == *"Permission denied"* ]] ; then
        echo "connection_status=\"no auth\"; connection_result=\"${ssh_status}\""
    else
        echo "connection_status=\"fail\"; connection_result=\"${ssh_status}\""
    fi
}

test_connection_cmd() {
    host=$1
    if [[ -z "${host}" ]] then
        host="${DestinationHost}"
    fi
    echo "<h2>Trying to connect to ${host} over SSH..<br>"

    eval $(test_connection "${host}")
    case "${connection_status}" in
        ("ok") echo "Success!<br>" ;;
        ("no auth") echo "Authentication failed. Make sure buddy has enabled \"Buddy's Backups\" and entered your public key.<br>" ;;
        ("fail") echo "Failed: ${connection_result}<br>" ;;
        (*) echo "unexpected error" ;;
    esac

    echo "</h2>"
}

get_buddy_snapshots() {
    cmd="zfs list -o name,origin -t filesystem,volume -Hr '${SendDestinationDataset}'"
    ssh_result=$(ssh -i "${ssh_key_path}" -o BatchMode=yes -o ConnectTimeout=5 "${username}@${DestinationHost}" "${cmd}" 2>&1)
    if [ $? -ne 0 ]; then
        ssh_result=$(echo "${ssh_result}" | sed 's/\r//g') # Remove ^M characters
        printf '{"status": "failed", "error": "%s"}' "${ssh_result}"
        return
    fi
    ## Enable for debugging
    # echo "full cmd: ssh -i \"${ssh_key_path}\" -o BatchMode=yes -o ConnectTimeout=5 \"${username}@${DestinationHost}\" \"${cmd}\" 2>&1"
    # echo "ssh_result: ${ssh_result}"

    # ssh_result should now contain one line per dataset/child dataset

    cmds=()
    datasets=()
    while IFS= read -r line; do
        dataset=$(echo "${line}" | sed 's/\s.*$//')
        cmds+=( "zfs get -Hpd 1 -t snapshot guid,creation '${dataset}'" )
        datasets+=( "${dataset}" )
    done <<< "${ssh_result}"
    
    json="{\"status\": \"ok\", \"data\": {"
    for ((i = 0; i < ${#cmds[@]}; i++))
    do
        json+="\"${datasets[$i]}\":{"
        ssh_sub_result=$(ssh -i "${ssh_key_path}" -o BatchMode=yes -o ConnectTimeout=5 "${username}@${DestinationHost}" "${cmds[$i]}" 2>&1)
        if [ $? -ne 0 ]; then
            ssh_sub_result=$(echo "${ssh_sub_result}" | sed 's/\r//g') # Remove ^M characters
            printf '{"status": "failed", "error": "%s"}' "${ssh_sub_result}"
            return
        fi

        while IFS= read -r line; do
            # Parse out snap, guid, creation from every 2 lines
            # examples lines:
            # disk4/offsite_backup/appdata@syncoid_2025-01-21:03:00:03-GMT01:00        guid    13997382453328167196    -
            # disk4/offsite_backup/appdata@syncoid_2025-01-21:03:00:03-GMT01:00        creation        1737424803      -

            snap=$(echo \"${line}\" | tr -s ' ' | cut -d '@' -f 2 | cut -d ' ' -f 1)
            guid=$(echo \"${line}\" | tr -s ' ' | cut -d ' ' -f 3)
            IFS= read -r line
            creation=$(echo \"${line}\" | tr -s ' ' | cut -d ' ' -f 3)

            json+="\"${snap}\":{\"guid\":\"${guid}\",\"creation\":\"${creation}\"}," 
        done <<< "${ssh_sub_result}"
        json="${json::-1}" # Remove trailing comma

        json+="},"
    done
    json="${json::-1}" # Remove trailing comma
    json+="}}"
    echo "${json}"
}

update_sanoid_conf() {
    # save retention for buddy's backups to sanoid conf
    sanoid_conf=$(printf "[${ReceiveDestinationDataset}]\n\
    hourly = ${ReceiveDestinationRententionHourly}\n\
    daily = ${ReceiveDestinationRententionDaily}\n\
    weekly = ${ReceiveDestinationRententionWeekly}\n\
    monthly = ${ReceiveDestinationRententionMonthly}\n\
    yearly = ${ReceiveDestinationRententionYearly}\n\
    autosnap = no\n\
    autoprune = yes\n\
    recursive = yes\n")
    
    # save manual entries from "snapshot creation and pruning" section in settings
    if [ -f "${extra_sanoid_config_path}" ]; then
        . $read_ini_script
        read_ini "${extra_sanoid_config_path}"
        for section in $INI__ALL_SECTIONS; do 
            local dataset=$(declare | grep "^INI__${section}__dataset" | cut -d "=" -f 2)
            if [[ "${dataset}" == "${ReceiveDestinationDataset}"* ]]; then
                echo "Error: Buddy's destination dataset '${dataset}' also specified in 'Snapshot creation and pruning' section. Remove it from there!" | ${log_script}
                continue
            fi
            printf -v sanoid_conf "${sanoid_conf}\n\n[${dataset}]\n"
            for var in $(declare | grep "^INI__${section}__"); do
                local key_val=$(echo ${var} | cut -d "_" -f 5)
                local key=$(echo ${key_val} | cut -d "=" -f 1)
                local val=$(echo ${key_val} | cut -d "=" -f 2)
                if [[ "${key}" == "dataset" ]]; then
                    continue
                fi
                printf -v sanoid_conf "${sanoid_conf}    ${key} = ${val}\n"
            done
        done
    fi
    echo "${sanoid_conf}" > "${sanoid_config_path}"
}

uninstall() {
    disable_backups_to_buddy
    disable_backups_from_buddy
    disable_sanoid_cron
    disable_syncoid_cron
}

# read our configuration.
CONFIG="/boot/config/plugins/${plugin}/${plugin}.cfg"
source $CONFIG

username="buddybackup"
plugin_path="/boot/config/plugins/${plugin}"
ssh_key_path="${plugin_path}/buddybackup_sender_key"
sanoid_cron_file="${plugin_path}/sanoid.cron"
syncoid_cron_file="${plugin_path}/syncoid.cron"
sanoid_config_path="${plugin_path}/sanoid.conf"
empath="/usr/local/emhttp/plugins/buddybackup"
sanoid_bin="${empath}/deps/sanoid"
syncoid_bin="${empath}/deps/syncoid"
log_script="${empath}/scripts/log.sh"
read_ini_script="${empath}/scripts/read_ini.sh"
syncoid_flags="--no-privilege-elevation --no-sync-snap --sendoptions=w --pv-options='-pterbf' --compress=zstdmt-fast"
extra_sanoid_config_path="${plugin_path}/snapshots.cfg"

case "$1" in
	('update')
		update
	;;
    ('send_backup')
		send_backup "$2"
	;;
    ('enable_sanoid_cron')
		enable_sanoid_cron
	;;
    ('disable_sanoid_cron')
		disable_sanoid_cron
	;;
    ('test_connection')
		test_connection_cmd "$2"
	;;
    ('get_buddy_snapshots')
        get_buddy_snapshots
    ;;
    ('restore_snapshot')
        restore_snapshot "$2" "$3" "$4" "$5" "$6"
    ;;
    ('update_sanoid_conf')
        update_sanoid_conf
    ;;
    ('uninstall')
		uninstall
	;;
	(*)
		echo "usage $0 update|send_backup|enable_sanoid_cron|disable_sanoid_cron|test_connection|get_buddy_snapshots|restore_snapshot|uninstall"
esac