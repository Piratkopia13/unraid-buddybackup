#!/bin/bash
set -o pipefail

plugin="buddybackup"

# cd /mnt/user/sonic/buddybackup_plugin && ./makepkg.sh && upgradepkg --install-new --reinstall buddybackup.txz

list_descendants() {
  local children=$(ps -o pid= --ppid "$1")
  for pid in $children; do
    list_descendants "$pid"
  done
  echo "$children"
}
cleanup() {
    # Kill child processes
    kill $(list_descendants $$) >/dev/null 2>&1
}
trap cleanup EXIT

unraid_notify() {
    # Call the Unraid notification script
    /usr/local/emhttp/webGui/scripts/notify -s "BuddyBackup" -d "$1" -i "$2"
}

# Default output is console, use optional parameter "nchan" to write to that nchan channel as well
write() {
    local nchan="$1"
    shift  # Shift arguments to access messages

    if [[ -n "$nchan" ]]; then
        local url="http://localhost/pub/buddybackup-${nchan}?buffer_length=10"
        local socket="/var/run/nginx.socket"

        for message in "$@"; do
            curl -o /dev/null --unix-socket "${socket}" -X POST -d "${message}" "${url}" >/dev/null 2>&1
        done
    fi
    
    for message in "$@"; do
        echo "${message}"
    done
}

# Runs cmd and continously sends output to nchan if specified, otherwise runs cmd and echos result afterwards
run_and_write_output() {
    local nchan="$1"  # Set to empty string to only write to console. Otherwise it will be sent to the nchan channel with this name
    local cmd="$2"

    if [[ -n "$nchan" ]]; then
        local url="http://localhost/pub/buddybackup-${nchan}?buffer_length=10"
        local socket="/var/run/nginx.socket"

        cmd+=" | tee >( stdbuf -oL tr '\r' '\n' | xargs -I % curl -o /dev/null --unix-socket \"${socket}\" -X POST --data-binary \"%\" \"${url}\" >/dev/null 2>&1)"
    fi

    result=$(eval "$cmd")
    local error_code=$?
    echo "${result}"
    return "${error_code}"
}

enable_backups_from_buddy() {
    if [[ -z "${ReceiveDestinationDataset}" ]]; then
        err="Can not enable backups from buddy, no recieve destination dataset set."
        logger "${err}" -t"${plugin}"
        echo "${err}"
        return
    fi

    # add buddybackup to "AllowUsers list" in /etc/ssh/sshd_config if AllowUsers exists (and restart sshd)
    # note: This probably makes it incompatible with other plugins that modify this line, such as "SSH Config Tool" by DocGyver
    sed -i 's/^#\?AllowUsers .*/AllowUsers root/' /etc/ssh/sshd_config
    sed -i 's/^#\?AllowUsers \(.*\)/AllowUsers \1 '${username}'/' /etc/ssh/sshd_config
    /etc/rc.d/rc.sshd restart >/dev/null 2>&1

    # make buddybackup user (with a homedir)
    useradd -m -s /bin/bash "${username}" >/dev/null 2>&1
    # copy public key to homedir/.ssh/authorized_keys. prepend with: 'restrict,command="path/to/restrict_zfs" '
    mkdir "/home/${username}/.ssh" >/dev/null 2>&1
    chmod 700 "/home/${username}/.ssh"
    touch "/home/${username}/.ssh/authorized_keys" >/dev/null 2>&1
    chmod 644 "/home/${username}/.ssh/authorized_keys"
    chown -R ${username}:${username} "/home/${username}/"
    echo "restrict,command=\"${empath}/deps/restrict_zfs\" ${DestinationPubSSHKey}" > "/home/${username}/.ssh/authorized_keys"

    zfs allow -u "${username}" create,mount,receive,send "${ReceiveDestinationDataset}"
}

disable_backups_from_buddy() {
    # remove buddybackup from "AllowUsers list" in /etc/ssh/sshd_config (and restart sshd)
    sed -i 's/ '${username}'//' /etc/ssh/sshd_config
    /etc/rc.d/rc.sshd restart >/dev/null 2>&1

    rm -r "/home/${username}" >/dev/null 2>&1

    # todo: if $ReceiveDestinationDataset has changed since enable_backups_from_buddy() we don't know which dataset to zfs unallow. Fix that
    if [[ "${ReceiveDestinationDataset}" ]]; then
        zfs unallow -u "${username}" create,mount,receive,send "${ReceiveDestinationDataset}" >/dev/null 2>&1
    fi

    userdel "${username}" >/dev/null 2>&1
}

remove_cron_files() {
    logger "Removing cron files" -t"${plugin}"

    rm "${plugin_path}/*.cron" >/dev/null 2>&1
    /usr/local/sbin/update_cron
}

update() {
    # generate new ssh keys to access buddy if the keys don't already exist
    if [ ! -f "${ssh_key_path}" ] || [ ! -f "${ssh_key_path}.pub" ]; then
        echo "Generating new key pair.."
        rm "${ssh_key_path}" >/dev/null 2>&1
        rm "${ssh_key_path}.pub" >/dev/null 2>&1
        ssh-keygen -q -t ed25519 -f "${ssh_key_path}" -N ''
    fi

    # Make sure deps are executable
    chmod +x "${sanoid_bin}"
    chmod +x "${syncoid_bin}"

    # remove old entries to known_host
    stripped=$(sed -n '1,/# buddybackup start/p;/# buddybackup end/,$p' ~/.ssh/known_hosts | sed -n '/^# buddybackup /d;p')
    echo "${stripped}" > ~/.ssh/known_hosts
    if [[ -n "${DestinationHost}" ]]; then
        # append target as known host. This gets rid of strange hostfile_replace_entries/update_known_hosts errors during remote ssh commands
        # This is done as long as a destination host is set regardless if backups are enabled or not since we still need to eg. run get_buddy_snapshots
        echo "# buddybackup start" >> ~/.ssh/known_hosts
        ssh-keyscan -H "${DestinationHost}" >> ~/.ssh/known_hosts
        echo "# buddybackup end" >> ~/.ssh/known_hosts
    fi
}

dataset_exists() {
    local dataset="$1"
    [[ $(zfs get -Ho value type "${dataset}" 2>&1) != *"dataset does not exist" ]]
}
is_encrypted() {
    local dataset="$1"
    [[ $(zfs get -Ho value encryption "${dataset}" 2>&1) != "off" ]]
}

send_backup() {
    logger "Sending backup to buddy" -t"${plugin}"

    local source_dataset="${1}"
    local recursive="${2}"
    local destination_host="${3}"
    local destination_dataset="${4}"

    local nchan="send"
    error=""
    if ! is_encrypted "${source_dataset}"; then
        error="Source dataset '${source_dataset}' is not encrypted!"
    fi
    if ! dataset_exists "${source_dataset}"; then
        error="Source dataset '${source_dataset}' does not exist!"
    fi

    if [ -n "${error}" ]; then
        error="Aborting backup. ${error}"
        write "${nchan}" "${error}"
        unraid_notify "${error}" "alert"
        return
    fi

    local my_syncoid_flags="${syncoid_flags}"
    if [[ "${recursive}" == "yes" ]] then
        my_syncoid_flags+=" --recursive"
    fi
    if result=$(run_and_write_output "${nchan}" "${syncoid_bin} ${my_syncoid_flags} --sshkey \"${ssh_key_path}\" \"${source_dataset}\" \"${username}@${destination_host}:${destination_dataset}\" 2>&1"); then
        printf -v result "\nSuccessfully synced backup to buddy!"
    else 
        local error_code=$?
        unraid_notify "Sending backup failed. Error code ${error_code}. Full output: ${result}" "alert"
        printf -v result "Sending backup failed. Error code ${error_code}."
    fi
    write "${nchan}" "${result}"

    if [[ "${nchan}" ]]; then
        write "${nchan}" "[[rc.buddybackup finished]]"
    fi
}

restore_snapshot() {
    mode=$1
    snapshot=$2
    source_dataset=$3
    destination_dataset=$4

    # If last param is "nchan" we send output to nchan channel "restore" instead of echo
    nchan=$5
    if [[ "${nchan}" == "nchan" ]]; then
        nchan="restore"
    else
        nchan=""
    fi

    logger "Restoring backup from buddy" -t"${plugin}"

    error_code=-1
    result=""
    case "$mode" in
        ('selected')
            result=$(run_and_write_output "${nchan}" "${syncoid_bin} ${syncoid_flags} --include-snaps=\"${snapshot}\" --sshkey \"${ssh_key_path}\" \"${username}@${DestinationHost}:${source_dataset}\" \"${destination_dataset}\" 2>&1");
            error_code=$?
        ;;
        ('selected_and_newer')
            # todo: this requires something like
            # syncoid --include-snaps="(?:wanted_snapshot|newer_snap1|newer_snap2|...|common_parent_snapshot)
            # but common_parent_snapshot has to be found which is the hard part
            write "${nchan}" "Restore mode '${mode}' is not implemented yet"
            return
        ;;
        ('all')
            result=$(run_and_write_output "${nchan}" "${syncoid_bin} ${syncoid_flags} --sshkey \"${ssh_key_path}\" \"${username}@${DestinationHost}:${source_dataset}\" \"${destination_dataset}\" 2>&1");
            error_code=$?
        ;;
        (*)
            write "${nchan}" "Invalid restore mode specified: (${mode})"
            return
    esac

    if [ $error_code -eq 0 ]; then
        if [[ -n "${nchan}" ]]; then
            printf -v result "\nSuccessfully restored from buddy!"
            unraid_notify "Restoring from buddy finished successfully!" "normal"
        else
            printf -v result "${result}\n\nSuccessfully restored from buddy!"
        fi
    else 
        full_error=""
        printf -v full_error "Restoring from buddy failed. Error code ${error_code}. Full output:\n\n${result}"
        if [[ -n "${nchan}" ]]; then
            unraid_notify "${full_error}" "alert"
            printf -v result "Restoring from buddy failed. Error code ${error_code}."
        else
            result="${full_error}"
        fi
    fi
    write "${nchan}" "${result}"

    if [[ "${nchan}" ]]; then
        write "${nchan}" "[[rc.buddybackup finished]]"
    fi
}

test_connection() {
    host=$1
    if [[ -z "${host}" ]] then
        host="${DestinationHost}"
    fi
    # test SSH connection to buddy
    ssh_status=$(ssh -i "${ssh_key_path}" -o BatchMode=yes -o ConnectTimeout=5 "${username}@${host}" echo ok 2>&1)
    if [[ "${ssh_status}" == ok ]] || [[ "${ssh_status}" == *"hostfile_replace_entries"* ]]; then
        echo "connection_status=\"ok\"; connection_result=\"${ssh_status}\""
    elif [[ "${ssh_status}" == *"Permission denied"* ]] ; then
        echo "connection_status=\"no auth\"; connection_result=\"${ssh_status}\""
    else
        echo "connection_status=\"fail\"; connection_result=\"${ssh_status}\""
    fi
}

test_connection_cmd() {
    host=$1
    if [[ -z "${host}" ]] then
        host="${DestinationHost}"
    fi
    echo "<h2>Trying to connect to ${host} over SSH..<br>"

    eval $(test_connection "${host}")
    case "${connection_status}" in
        ("ok") echo "Success!<br>" ;;
        ("no auth") echo "Authentication failed. Make sure buddy has enabled \"Buddy's Backups\" and entered your public key.<br>" ;;
        ("fail") echo "Failed: ${connection_result}<br>" ;;
        (*) echo "unexpected error" ;;
    esac

    echo "</h2>"
}

get_buddy_snapshots() {
    cmd="zfs list -o name,origin -t filesystem,volume -Hr '${SendDestinationDataset}'"
    ssh_result=$(ssh -i "${ssh_key_path}" -o BatchMode=yes -o ConnectTimeout=5 "${username}@${DestinationHost}" "${cmd}" 2>&1)
    if [ $? -ne 0 ]; then
        ssh_result=$(echo "${ssh_result}" | jq -Rrsa . | sed -e 's/^"//' -e 's/"$//')
        printf '{"status": "failed", "error": "%s"}' "${ssh_result}"
        return
    fi
    ## Enable for debugging
    # echo "full cmd: ssh -i \"${ssh_key_path}\" -o BatchMode=yes -o ConnectTimeout=5 \"${username}@${DestinationHost}\" \"${cmd}\" 2>&1"
    # echo "ssh_result: ${ssh_result}"

    # ssh_result should now contain one line per dataset/child dataset

    cmds=()
    datasets=()
    while IFS= read -r line; do
        # Basic error checking, ensure line begins with dataset name
        if [[ "${line}" != "${SendDestinationDataset}"* ]]; then
            ssh_result=$(echo "${ssh_result}" | jq -Rrsa . | sed -e 's/^"//' -e 's/"$//')
            printf '{"status": "failed", "error": "%s"}' "Buddy returned invalid line: ${ssh_result}"
            return
        fi

        dataset=$(echo "${line}" | sed 's/\s.*$//')
        cmds+=( "zfs get -Hpd 1 -t snapshot guid,creation '${dataset}'" )
        datasets+=( "${dataset}" )
    done <<< "${ssh_result}"
    
    json="{\"status\": \"ok\", \"data\": {"
    for ((i = 0; i < ${#cmds[@]}; i++))
    do
        json+="\"${datasets[$i]}\":{"
        ssh_sub_result=$(ssh -i "${ssh_key_path}" -o BatchMode=yes -o ConnectTimeout=5 "${username}@${DestinationHost}" "${cmds[$i]}" 2>&1)
        if [ $? -ne 0 ]; then
            ssh_sub_result=$(echo "${ssh_sub_result}" | jq -Rrsa . | sed -e 's/^"//' -e 's/"$//')
            printf '{"status": "failed", "error": "%s"}' "${ssh_sub_result}"
            return
        fi

        while IFS= read -r line; do
            # Parse out snap, guid, creation from every 2 lines
            # examples lines:
            # disk4/offsite_backup/appdata@syncoid_2025-01-21:03:00:03-GMT01:00        guid    13997382453328167196    -
            # disk4/offsite_backup/appdata@syncoid_2025-01-21:03:00:03-GMT01:00        creation        1737424803      -

            snap=$(echo \"${line}\" | tr -s ' ' | cut -d '@' -f 2 | cut -d ' ' -f 1)
            guid=$(echo \"${line}\" | tr -s ' ' | cut -d ' ' -f 3)
            IFS= read -r line
            creation=$(echo \"${line}\" | tr -s ' ' | cut -d ' ' -f 3)

            json+="\"${snap}\":{\"guid\":\"${guid}\",\"creation\":\"${creation}\"}," 
        done <<< "${ssh_sub_result}"
        json="${json::-1}" # Remove trailing comma

        json+="},"
    done
    json="${json::-1}" # Remove trailing comma
    json+="}}"
    echo "${json}"
}

uninstall() {
    disable_backups_from_buddy
    remove_cron_files
}

# read our configuration.
CONFIG="/boot/config/plugins/${plugin}/${plugin}.cfg"
source $CONFIG

username="buddybackup"
plugin_path="/boot/config/plugins/${plugin}"
ssh_key_path="${plugin_path}/buddybackup_sender_key"
empath="/usr/local/emhttp/plugins/buddybackup"
sanoid_bin="${empath}/deps/sanoid"
syncoid_bin="${empath}/deps/syncoid"
syncoid_flags="--no-privilege-elevation --no-sync-snap --sendoptions=w --pv-options='-pterbf' --compress=zstdmt-fast"

case "$1" in
	('update')
		update
	;;
    ('send_backup')
		send_backup "$2" "$3" "$4" "$5"
	;;
    ('test_connection')
		test_connection_cmd "$2"
	;;
    ('get_buddy_snapshots')
        get_buddy_snapshots
    ;;
    ('restore_snapshot')
        restore_snapshot "$2" "$3" "$4" "$5" "$6"
    ;;
    ('enable_backups_from_buddy')
        enable_backups_from_buddy
    ;;
    ('disable_backups_from_buddy')
        disable_backups_from_buddy
    ;;
    ('uninstall')
		uninstall
	;;
	(*)
		echo "usage $0 update|send_backup|test_connection|get_buddy_snapshots|restore_snapshot|uninstall"
esac